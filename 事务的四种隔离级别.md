### 事务的特性（ACID）
* 原子性（Atomicity）
```
    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败
    
则不能对数据库有任何影响。
```
* 一致性（Consistency）
```
   
```
* 隔离性（Isolation）
```
    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个
   
并发事务之间要相互隔离。
```
* 持久性（Durability）
```
    持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交

事务的操作。
   
    例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务
    
以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库

因为故障而没有执行事务的重大错误。
```
### 不考虑事务的隔离产生的问题
* 脏读(Drity Read)
```
    某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数
    
据就会是不正确的。
```
* 不可重复读(Non-repeatable read)
```
    在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
```
* 幻读(Phantom Read)
```
    在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先
    
前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
```
### mysql 事务隔离级别
* Read Uncommitted（读取未提交内容）
 ```
     在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好
     
 多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
 ```
 * Read Committed（读取提交内容）
 ```
    这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的
    
改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，

所以同一select可能
 
 返回不同结果。
 ```
 * Repeatable Read（可重读）
 ```
    这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个
    
棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户

再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency 

Control）机制解决了该问题。
 ```
 * Serializable（可串行化） 
 ```
     这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。
     
 在这个级别，可能导致大量的超时现象和锁竞争。
 ```
 在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：
 
 ![](https://github.com/Yangliangfeng/Mysql/raw/master/images/mysql1.jpg)
 
 ### 关于mysql隔离的几个操作命令
 ```
 1. 设置全局的隔离级别
 
 set GLOBAL TRANSACTION ISOLATION LEVEL read uncommitted
 
 2.查看某个表的事务级别
 
 select @@表名_isolation
 ```
