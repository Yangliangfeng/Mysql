### 视图

* 定义

  视图是一种虚拟存在的表，对于使用视图的用户来说基本上是透明的。视图并不在数据库中实际存在，行和列数据
  
来自定义视图的查询总使用的表，并且是在使用视图时动态生成的。

* 优势

  1.简单 
  
  使用视图的用户完全不需要关系后面对应的表结构、关联条件和筛选条件，对用户来说已经是过滤好的符合条件的
  
  结果集
  
  2.安全
  
  使用视图的用户只能访问他们被允许的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以
  
  简单的实现
  
  3.数据独立
  
  一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通
  
  过修改视图来解决，不会造成对访问者的影响。
  
 * 创建视图
 
 ```
CREATE [OR REPLACE] VIEW 视图名(列1，列2...)

AS SELECT (列1，列2...)

FROM ...;

[WITH [CASCADED|LOCAL] CHECK OPTION]

注：一般情况下，在创建有条件限制的视图时，加上“WITH CHECK OPTION”命令
 ```
 * 查看视图定义
 
 show create view 视图名称\G
 
 * 缺点
 
 1.性能相对较差，简单的查询也会变得稍显复杂
 
 2.修改不方便，特变是复杂的聚合视图基本无法修改
 
 3.术语：RDBMS即关系数据库管理系统(Relational Database Management System)
 
 ### 存储过程
 
 * 存储过程的定义
 
 存储过程是存储在数据库目录中的一段声明性SQL语句。
 
 * MySQL存储过程的优点
 
 1. 通常存储过程有助于提高应用程序的性能。
 
 当创建，存储过程被编译之后，就存储在数据库中。 但是，MySQL实现的存储过程略有不同。 MySQL存储过程按需编译。 
 
 在编译存储过程之后，MySQL将其放入缓存中。 MySQL为每个连接维护自己的存储过程高速缓存。 如果应用程序在单个连
 
 接中多次使用存储过程，则使用编译版本，否则存储过程的工作方式类似于查询。
 
 2. 存储过程有助于减少应用程序和数据库服务器之间的流量，因为应用程序不必发送多个冗长的SQL语句，而只能发送存储
 
 过程的名称和参数。
 
 3. 存储的程序对任何应用程序都是可重用的和透明的。 存储过程将数据库接口暴露给所有应用程序，以便开发人员不必开发存
 
 储过程中已支持的功能。
 
 4. 存储的程序是安全的。 数据库管理员可以向访问数据库中存储过程的应用程序授予适当的权限，而不向基础数据库表提供任何
 
 权限。
 
 * MySQL存储过程的缺点
 
 1. 如果使用大量存储过程，那么使用这些存储过程的每个连接的内存使用量将会大大增加。 此外，如果您在存储过程中过度使用
 
 大量逻辑操作，则CPU使用率也会增加，因为数据库服务器的设计不当于逻辑运算。
 
 2. 存储过程的构造使得开发具有复杂业务逻辑的存储过程变得更加困难。
 
 3. 很难调试存储过程。只有少数数据库管理系统允许您调试存储过程。不幸的是，MySQL不提供调试存储过程的功能。
 
 4. 开发和维护存储过程并不容易。开发和维护存储过程通常需要一个不是所有应用程序开发人员拥有的专业技能。这可
 
 能会导致应用程序开发和维护阶段的问题。
 
 * 存储过程的实例（一）
 
 ```
 DELIMITER //;
 
 create procedure originplayer(IN ori int(11),OUT total int(11))
 
 begin
 
    select count(*) from player where origin = ori into total;
    
 end//
 
 delimiter ;
 
 语法解析：
 
 delimiter是分割符的意思。因为MySQL默认以“;”为分割符，如果没有声明分割符，那么编译器会把存储过程当作SQL语句进行
 
 处理，则存储过程的编译过程会报错。“delimiter //”声明分割符是“//”。存储过程中的代码结束之后，再次声明“delimiter ;”，
 
 将“;”作为分割符。
 
 创建的存储过程可能会有输入、输出、输入输出参数。本例有一个输入参数“ori”，类型是int，一个输出参数“total”，类型是int。
 
 如果有多个参数，用“,”分割开。
 
 MySQL称存储过程的执行为调用，因此执行存储过程的语句是CALL。CALL接收存储过程的名字以及需要传递给它的任何参数。
 
 ```
 * 存储过程参数
 
 ```
 存储过程共有三种参数类型，INT、OUT、INOUT。
 
 1. IN输入参数：该参数的值必须在调用存储过程时指定。如果在存储过程中修改了该参数的值，该参数的值仍然是修改之前的值。
 
 2. OUT输出参数：指定MySQL变量，接收调用存储过程后返回的值。
 
 3. INOUT输入输出参数：调用时指定，并且可被改变和返回。
 ```
 * 存储过程变量的定义
 
 ```
 DECLARE variable_name datatype [default value];
 
 datatype与MySQL的数据类型一样，如：int、float、date、varchar(length)；
 
 变量赋值：
 
 SET variable_name = value
 ```
 * 查询存储过程
 ```
 # 列出所有的存储过程
 show procedure status\G

 # 列出某个库拥有的存储过程：
 select name from mysql.proc where db='project';

 # 查询存储过程的详细信息：
 show create procedure project.originplayer;
 
 # 删除存储过程：
 drop procedure project.originplayer;
 ```
 * 游标的实例
 ```
 DELIMITER //
 create procedure getPlayId()
 begin
 declare id int(11);
 declare done boolean default 0;
 declare cur cursor for select playerid from player;
 declare continue handler for not found set done = 1;
 open cur;
 repeat
    fetch cur into id;
    util done end repeat;
 close cur;
 end //
 delimiter ;

 语法解析：
 
 1. MySQL游标仅用于存储过程中
 
 2. DECLARE语句用来定义和命名游标，这里的游标为“cur”
 
 3. OPEN和CLOSE用来打开和关闭游标。在处理OPEN语句时执行查询，存储检索出的数据以供浏览。CLOSE游标将释放游标占用的所有
 
 内存和内部资源。如果没有明确关闭游标，MySQL会在到达END语句时自动关闭游标；
 
 4. 在一个游标被打开后，使用FETCH语句可以访问游标的每一行，并可以指定将数据存储在什么地方
 
 5. 上面例子中，FETCH语句在REPEAT内，因此它反复执行，直到done为真（由UTIL done END REPEAT;指定）；
 
 6. CONTINUE HANDLER，当REPEAT由于没有更多的行供循环而不能继续时出现这个条件，将done设置为1，此时REPEAT终止
 ```
 * 游标DECLARE语句的次序：
 
 DECLARE语句的发布存在特定的次序。用DECLARE语句定义的局部变量必须在定义任意游标或句柄之前；句柄的定义必须在游标之后。
 
 * 重复或循环：
 ```
 read_loop:LOOP
    ->       -- 提取游标中的数据
    ->       FETCH cur INTO id,origin;
    ->       -- 声明何时结束循环
    ->       IF done THEN
    ->         LEAVE read_loop;
    ->       END IF;
    ->       -- 循环时的事件
    ->       IF origin=0
    ->       THEN
    ->         INSERT INTO consumption VALUES (0,1525467600);
    ->       ELSE
    ->         INSERT INTO consumption_other VALUES(0,1525467600);
    ->       END IF;
    ->     END LOOP;
 ```
 * 带有游标的存储过程
 ```
 需求：
    有三张表：Player、Consumption、Consumption_other。Player表中记录用户信息（playerid、origin等字段），
    
    Consumption和Consumption_other记录用户的消费信息。现需要根据Player表中的origin字段，分别向Consumption
    
    和Consumption_other表中插入一条消费记录。规定：Player表中origin=0的，将信息插入到Consumption表中；
    
    Player表中origin不为0的，将信息插入到Consumption_other表中。
    
  代码：
    
    mysql> DELIMITER //
mysql> CREATE PROCEDURE `add_consumption`()
    -> BEGIN
    ->   -- 定义需要接收游标数据的变量
    ->   DECLARE id int(11);
    ->   DECLARE origin int(11);
    ->   -- 定义遍历数据结束标志
    ->   DECLARE done BOOLEAN DEFAULT 0;
    ->   -- 定义游标
    ->   DECLARE cur CURSOR FOR SELECT
    ->     player.playerid as id,
    ->     player.origin as origin
    ->   FROM player;
    ->   -- 将结束标志绑定到游标
    ->   DECLARE CONTINUE HANDLER FOR NOT FOUND SET done=1;
    ->   -- 打开游标
    ->   OPEN cur;
    ->     -- 关闭事务自动提交
    ->     SET autocommit=0;
    ->     -- 开始循环
    ->     read_loop:LOOP
    ->       -- 提取游标中的数据
    ->       FETCH cur INTO id,origin;
    ->       -- 声明何时结束循环
    ->       IF done THEN
    ->         LEAVE read_loop;
    ->       END IF;
    ->       -- 循环时的事件
    ->       IF origin=0
    ->       THEN
    ->         INSERT INTO consumption VALUES (0,1525467600);
    ->       ELSE
    ->         INSERT INTO consumption_other VALUES(0,1525467600);
    ->       END IF;
    ->     END LOOP;
    ->     commit;
    ->     -- 关闭游标
    ->   CLOSE cur;
    -> END
    -> //
mysql> DELIMITER ;
mysql> call add_consumption();
 ```
  * 存储过程的实例（一）
```
BEGIN
  DECLARE count_year int;
  DECLARE Done INT DEFAULT 0;
  DECLARE cur CURSOR FOR select DISTINCT DATE_FORMAT(hire_date,'%Y') from employees;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET Done=1;
  
  OPEN cur;
  FETCH NEXT FROM cur INTO count_year;
  set @tbname='';
  set @sqlstr='';
  WHILE Done<>1 DO
      set @tbname=concat('employees_',count_year);
      set @sqlstr=concat('DROP TABLE IF EXISTS ',@tbname);
      PREPARE stmts  FROM @sqlstr;
      EXECUTE stmts;
      
      set @sqlstr=concat('create table ',@tbname,' like employees ');//like 主要是复制employees的表的主键和索引
      PREPARE stmts  FROM @sqlstr;
      EXECUTE stmts;
      
      set @sqlstr=concat('insert into  ',@tbname,' select * from employees where   DATE_FORMAT(hire_date,\'%Y\')=',count_year);
      PREPARE stmts FROM @sqlstr;
      EXECUTE stmts;
      
      //释放语句
      DEALLOCATE PREPARE  stmts;
      set @tbname='';
      set @sqlstr='';
      FETCH NEXT FROM cur INTO count_year;
   end while;
END
```













 
 
 
 
